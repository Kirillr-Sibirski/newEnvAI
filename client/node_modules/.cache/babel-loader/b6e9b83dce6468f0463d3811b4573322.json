{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport aes from \"aes-js\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { Description } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nimport { getPassword, looseArrayify, searchPath } from \"./utils\";\nexport var CrowdsaleAccount = /*#__PURE__*/function (_Description) {\n  _inherits(CrowdsaleAccount, _Description);\n\n  var _super = _createSuper(CrowdsaleAccount);\n\n  function CrowdsaleAccount() {\n    _classCallCheck(this, CrowdsaleAccount);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(CrowdsaleAccount, [{\n    key: \"isCrowdsaleAccount\",\n    value: function isCrowdsaleAccount(value) {\n      return !!(value && value._isCrowdsaleAccount);\n    }\n  }]);\n\n  return CrowdsaleAccount;\n}(Description); // See: https://github.com/ethereum/pyethsaletool\n\nexport function decrypt(json, password) {\n  var data = JSON.parse(json);\n  password = getPassword(password); // Ethereum Address\n\n  var ethaddr = getAddress(searchPath(data, \"ethaddr\")); // Encrypted Seed\n\n  var encseed = looseArrayify(searchPath(data, \"encseed\"));\n\n  if (!encseed || encseed.length % 16 !== 0) {\n    logger.throwArgumentError(\"invalid encseed\", \"json\", json);\n  }\n\n  var key = arrayify(pbkdf2(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n  var iv = encseed.slice(0, 16);\n  var encryptedSeed = encseed.slice(16); // Decrypt the seed\n\n  var aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n  var seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed))); // This wallet format is weird... Convert the binary encoded hex to a string.\n\n  var seedHex = \"\";\n\n  for (var i = 0; i < seed.length; i++) {\n    seedHex += String.fromCharCode(seed[i]);\n  }\n\n  var seedHexBytes = toUtf8Bytes(seedHex);\n  var privateKey = keccak256(seedHexBytes);\n  return new CrowdsaleAccount({\n    _isCrowdsaleAccount: true,\n    address: ethaddr,\n    privateKey: privateKey\n  });\n}","map":{"version":3,"mappings":"AAAA;;;;;;AAEA,OAAOA,GAAP,MAAgB,QAAhB;AAGA,SAASC,UAAT,QAA2B,wBAA3B;AACA,SAASC,QAAT,QAAgC,sBAAhC;AACA,SAASC,SAAT,QAA0B,0BAA1B;AACA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,WAAT,QAA4B,wBAA5B;AACA,SAASC,WAAT,QAA4B,2BAA5B;AAEA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,OAAT,QAAwB,YAAxB;AACA,IAAMC,MAAM,GAAG,IAAIF,MAAJ,CAAWC,OAAX,CAAf;AAEA,SAASE,WAAT,EAAsBC,aAAtB,EAAqCC,UAArC,QAAuD,SAAvD;AASA,WAAaC,gBAAb;EAAA;;EAAA;;EAAA;IAAA;;IAAA;EAAA;;EAAA;IAAA;IAAA,OAQI,4BAAmBC,KAAnB,EAA6B;MACzB,OAAO,CAAC,EAAEA,KAAK,IAAIA,KAAK,CAACC,mBAAjB,CAAR;IACH;EAVL;;EAAA;AAAA,EAAsCT,WAAtC,E,CAaA;;AACA,OAAM,SAAUU,OAAV,CAAkBC,IAAlB,EAAgCC,QAAhC,EAAwD;EAC1D,IAAMC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWJ,IAAX,CAAb;EAEAC,QAAQ,GAAGR,WAAW,CAACQ,QAAD,CAAtB,CAH0D,CAK1D;;EACA,IAAMI,OAAO,GAAGrB,UAAU,CAACW,UAAU,CAACO,IAAD,EAAO,SAAP,CAAX,CAA1B,CAN0D,CAQ1D;;EACA,IAAMI,OAAO,GAAGZ,aAAa,CAACC,UAAU,CAACO,IAAD,EAAO,SAAP,CAAX,CAA7B;;EACA,IAAI,CAACI,OAAD,IAAaA,OAAO,CAACC,MAAR,GAAiB,EAAlB,KAA0B,CAA1C,EAA6C;IACzCf,MAAM,CAACgB,kBAAP,CAA0B,iBAA1B,EAA6C,MAA7C,EAAqDR,IAArD;EACH;;EAED,IAAMS,GAAG,GAAGxB,QAAQ,CAACE,MAAM,CAACc,QAAD,EAAWA,QAAX,EAAqB,IAArB,EAA2B,EAA3B,EAA+B,QAA/B,CAAP,CAAR,CAAyDS,KAAzD,CAA+D,CAA/D,EAAkE,EAAlE,CAAZ;EAEA,IAAMC,EAAE,GAAGL,OAAO,CAACI,KAAR,CAAc,CAAd,EAAiB,EAAjB,CAAX;EACA,IAAME,aAAa,GAAGN,OAAO,CAACI,KAAR,CAAc,EAAd,CAAtB,CAjB0D,CAmB1D;;EACA,IAAMG,MAAM,GAAG,IAAI9B,GAAG,CAAC+B,eAAJ,CAAoBC,GAAxB,CAA4BN,GAA5B,EAAiCE,EAAjC,CAAf;EACA,IAAMK,IAAI,GAAGjC,GAAG,CAACkC,OAAJ,CAAYC,KAAZ,CAAkBC,KAAlB,CAAwBlC,QAAQ,CAAC4B,MAAM,CAACd,OAAP,CAAea,aAAf,CAAD,CAAhC,CAAb,CArB0D,CAuB1D;;EACA,IAAIQ,OAAO,GAAG,EAAd;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,IAAI,CAACT,MAAzB,EAAiCc,CAAC,EAAlC,EAAsC;IAClCD,OAAO,IAAIE,MAAM,CAACC,YAAP,CAAoBP,IAAI,CAACK,CAAD,CAAxB,CAAX;EACH;;EAED,IAAMG,YAAY,GAAGpC,WAAW,CAACgC,OAAD,CAAhC;EAEA,IAAMK,UAAU,GAAGvC,SAAS,CAACsC,YAAD,CAA5B;EAEA,OAAO,IAAI5B,gBAAJ,CAAsB;IACzBE,mBAAmB,EAAE,IADI;IAEzB4B,OAAO,EAAErB,OAFgB;IAGzBoB,UAAU,EAAEA;EAHa,CAAtB,CAAP;AAKH","names":["aes","getAddress","arrayify","keccak256","pbkdf2","toUtf8Bytes","Description","Logger","version","logger","getPassword","looseArrayify","searchPath","CrowdsaleAccount","value","_isCrowdsaleAccount","decrypt","json","password","data","JSON","parse","ethaddr","encseed","length","throwArgumentError","key","slice","iv","encryptedSeed","aesCbc","ModeOfOperation","cbc","seed","padding","pkcs7","strip","seedHex","i","String","fromCharCode","seedHexBytes","privateKey","address"],"sources":["C:\\Users\\kiril\\Desktop\\newenvai\\client\\node_modules\\@ethersproject\\json-wallets\\src.ts\\crowdsale.ts"],"sourcesContent":["\"use strict\";\n\nimport aes from \"aes-js\";\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, Bytes } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { Description } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getPassword, looseArrayify, searchPath } from \"./utils\";\n\nexport interface _CrowdsaleAccount {\n    address: string;\n    privateKey: string;\n\n    _isCrowdsaleAccount: boolean;\n}\n\nexport class CrowdsaleAccount extends Description<_CrowdsaleAccount> implements ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n    readonly mnemonic?: string;\n    readonly path?: string;\n\n    readonly _isCrowdsaleAccount: boolean;\n\n    isCrowdsaleAccount(value: any): value is CrowdsaleAccount {\n        return !!(value && value._isCrowdsaleAccount);\n    }\n}\n\n// See: https://github.com/ethereum/pyethsaletool\nexport function decrypt(json: string, password: Bytes | string): ExternallyOwnedAccount {\n    const data = JSON.parse(json);\n\n    password = getPassword(password);\n\n    // Ethereum Address\n    const ethaddr = getAddress(searchPath(data, \"ethaddr\"));\n\n    // Encrypted Seed\n    const encseed = looseArrayify(searchPath(data, \"encseed\"));\n    if (!encseed || (encseed.length % 16) !== 0) {\n        logger.throwArgumentError(\"invalid encseed\", \"json\", json);\n    }\n\n    const key = arrayify(pbkdf2(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n\n    const iv = encseed.slice(0, 16);\n    const encryptedSeed = encseed.slice(16);\n\n    // Decrypt the seed\n    const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n    const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));\n\n    // This wallet format is weird... Convert the binary encoded hex to a string.\n    let seedHex = \"\";\n    for (let i = 0; i < seed.length; i++) {\n        seedHex += String.fromCharCode(seed[i]);\n    }\n\n    const seedHexBytes = toUtf8Bytes(seedHex);\n\n    const privateKey = keccak256(seedHexBytes);\n\n    return new CrowdsaleAccount ({\n        _isCrowdsaleAccount: true,\n        address: ethaddr,\n        privateKey: privateKey\n    });\n}\n\n"]},"metadata":{},"sourceType":"module"}