{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\n\nfunction now() {\n  return new Date().getTime();\n} // Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\n\n\nfunction checkNetworks(networks) {\n  var result = null;\n\n  for (var i = 0; i < networks.length; i++) {\n    var network = networks[i]; // Null! We do not know our network; bail.\n\n    if (network == null) {\n      return null;\n    }\n\n    if (result) {\n      // Make sure the network matches the previous networks\n      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {\n        logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n      }\n    } else {\n      result = network;\n    }\n  }\n\n  return result;\n}\n\nfunction median(values, maxDelta) {\n  values = values.slice().sort();\n  var middle = Math.floor(values.length / 2); // Odd length; take the middle\n\n  if (values.length % 2) {\n    return values[middle];\n  } // Even length; take the average of the two middle\n\n\n  var a = values[middle - 1],\n      b = values[middle];\n\n  if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n    return null;\n  }\n\n  return (a + b) / 2;\n}\n\nfunction serialize(value) {\n  if (value === null) {\n    return \"null\";\n  } else if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return JSON.stringify(value);\n  } else if (typeof value === \"string\") {\n    return value;\n  } else if (BigNumber.isBigNumber(value)) {\n    return value.toString();\n  } else if (Array.isArray(value)) {\n    return JSON.stringify(value.map(function (i) {\n      return serialize(i);\n    }));\n  } else if (typeof value === \"object\") {\n    var keys = Object.keys(value);\n    keys.sort();\n    return \"{\" + keys.map(function (key) {\n      var v = value[key];\n\n      if (typeof v === \"function\") {\n        v = \"[function]\";\n      } else {\n        v = serialize(v);\n      }\n\n      return JSON.stringify(key) + \":\" + v;\n    }).join(\",\") + \"}\";\n  }\n\n  throw new Error(\"unknown value type: \" + typeof value);\n} // Next request ID to use for emitting debug info\n\n\nvar nextRid = 1;\n;\n\nfunction stall(duration) {\n  var cancel = null;\n  var timer = null;\n  var promise = new Promise(function (resolve) {\n    cancel = function cancel() {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n\n      resolve();\n    };\n\n    timer = setTimeout(cancel, duration);\n  });\n\n  var wait = function wait(func) {\n    promise = promise.then(func);\n    return promise;\n  };\n\n  function getPromise() {\n    return promise;\n  }\n\n  return {\n    cancel: cancel,\n    getPromise: getPromise,\n    wait: wait\n  };\n}\n\nvar ForwardErrors = [Logger.errors.CALL_EXCEPTION, Logger.errors.INSUFFICIENT_FUNDS, Logger.errors.NONCE_EXPIRED, Logger.errors.REPLACEMENT_UNDERPRICED, Logger.errors.UNPREDICTABLE_GAS_LIMIT];\nvar ForwardProperties = [\"address\", \"args\", \"errorArgs\", \"errorSignature\", \"method\", \"transaction\"];\n;\n\nfunction exposeDebugConfig(config, now) {\n  var result = {\n    weight: config.weight\n  };\n  Object.defineProperty(result, \"provider\", {\n    get: function get() {\n      return config.provider;\n    }\n  });\n\n  if (config.start) {\n    result.start = config.start;\n  }\n\n  if (now) {\n    result.duration = now - config.start;\n  }\n\n  if (config.done) {\n    if (config.error) {\n      result.error = config.error;\n    } else {\n      result.result = config.result || null;\n    }\n  }\n\n  return result;\n}\n\nfunction normalizedTally(normalize, quorum) {\n  return function (configs) {\n    // Count the votes for each result\n    var tally = {};\n    configs.forEach(function (c) {\n      var value = normalize(c.result);\n\n      if (!tally[value]) {\n        tally[value] = {\n          count: 0,\n          result: c.result\n        };\n      }\n\n      tally[value].count++;\n    }); // Check for a quorum on any given result\n\n    var keys = Object.keys(tally);\n\n    for (var i = 0; i < keys.length; i++) {\n      var check = tally[keys[i]];\n\n      if (check.count >= quorum) {\n        return check.result;\n      }\n    } // No quroum\n\n\n    return undefined;\n  };\n}\n\nfunction getProcessFunc(provider, method, params) {\n  var normalize = serialize;\n\n  switch (method) {\n    case \"getBlockNumber\":\n      // Return the median value, unless there is (median + 1) is also\n      // present, in which case that is probably true and the median\n      // is going to be stale soon. In the event of a malicious node,\n      // the lie will be true soon enough.\n      return function (configs) {\n        var values = configs.map(function (c) {\n          return c.result;\n        }); // Get the median block number\n\n        var blockNumber = median(configs.map(function (c) {\n          return c.result;\n        }), 2);\n\n        if (blockNumber == null) {\n          return undefined;\n        }\n\n        blockNumber = Math.ceil(blockNumber); // If the next block height is present, its prolly safe to use\n\n        if (values.indexOf(blockNumber + 1) >= 0) {\n          blockNumber++;\n        } // Don't ever roll back the blockNumber\n\n\n        if (blockNumber >= provider._highestBlockNumber) {\n          provider._highestBlockNumber = blockNumber;\n        }\n\n        return provider._highestBlockNumber;\n      };\n\n    case \"getGasPrice\":\n      // Return the middle (round index up) value, similar to median\n      // but do not average even entries and choose the higher.\n      // Malicious actors must compromise 50% of the nodes to lie.\n      return function (configs) {\n        var values = configs.map(function (c) {\n          return c.result;\n        });\n        values.sort();\n        return values[Math.floor(values.length / 2)];\n      };\n\n    case \"getEtherPrice\":\n      // Returns the median price. Malicious actors must compromise at\n      // least 50% of the nodes to lie (in a meaningful way).\n      return function (configs) {\n        return median(configs.map(function (c) {\n          return c.result;\n        }));\n      };\n    // No additional normalizing required; serialize is enough\n\n    case \"getBalance\":\n    case \"getTransactionCount\":\n    case \"getCode\":\n    case \"getStorageAt\":\n    case \"call\":\n    case \"estimateGas\":\n    case \"getLogs\":\n      break;\n    // We drop the confirmations from transactions as it is approximate\n\n    case \"getTransaction\":\n    case \"getTransactionReceipt\":\n      normalize = function normalize(tx) {\n        if (tx == null) {\n          return null;\n        }\n\n        tx = shallowCopy(tx);\n        tx.confirmations = -1;\n        return serialize(tx);\n      };\n\n      break;\n    // We drop the confirmations from transactions as it is approximate\n\n    case \"getBlock\":\n      // We drop the confirmations from transactions as it is approximate\n      if (params.includeTransactions) {\n        normalize = function normalize(block) {\n          if (block == null) {\n            return null;\n          }\n\n          block = shallowCopy(block);\n          block.transactions = block.transactions.map(function (tx) {\n            tx = shallowCopy(tx);\n            tx.confirmations = -1;\n            return tx;\n          });\n          return serialize(block);\n        };\n      } else {\n        normalize = function normalize(block) {\n          if (block == null) {\n            return null;\n          }\n\n          return serialize(block);\n        };\n      }\n\n      break;\n\n    default:\n      throw new Error(\"unknown method: \" + method);\n  } // Return the result if and only if the expected quorum is\n  // satisfied and agreed upon for the final result.\n\n\n  return normalizedTally(normalize, provider.quorum);\n} // If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\n\n\nfunction waitForSync(config, blockNumber) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var provider;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            provider = config.provider;\n\n            if (!(provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1)) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\", provider);\n\n          case 3:\n            return _context.abrupt(\"return\", poll(function () {\n              return new Promise(function (resolve, reject) {\n                setTimeout(function () {\n                  // We are synced\n                  if (provider.blockNumber >= blockNumber) {\n                    return resolve(provider);\n                  } // We're done; just quit\n\n\n                  if (config.cancelled) {\n                    return resolve(null);\n                  } // Try again, next block\n\n\n                  return resolve(undefined);\n                }, 0);\n              });\n            }, {\n              oncePoll: provider\n            }));\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nfunction getRunner(config, currentBlockNumber, method, params) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var provider, filter;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            provider = config.provider;\n            _context2.t0 = method;\n            _context2.next = _context2.t0 === \"getBlockNumber\" ? 4 : _context2.t0 === \"getGasPrice\" ? 4 : _context2.t0 === \"getEtherPrice\" ? 5 : _context2.t0 === \"getBalance\" ? 8 : _context2.t0 === \"getTransactionCount\" ? 8 : _context2.t0 === \"getCode\" ? 8 : _context2.t0 === \"getStorageAt\" ? 13 : _context2.t0 === \"getBlock\" ? 18 : _context2.t0 === \"call\" ? 23 : _context2.t0 === \"estimateGas\" ? 23 : _context2.t0 === \"getTransaction\" ? 28 : _context2.t0 === \"getTransactionReceipt\" ? 28 : _context2.t0 === \"getLogs\" ? 29 : 35;\n            break;\n\n          case 4:\n            return _context2.abrupt(\"return\", provider[method]());\n\n          case 5:\n            if (!provider.getEtherPrice) {\n              _context2.next = 7;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", provider.getEtherPrice());\n\n          case 7:\n            return _context2.abrupt(\"break\", 35);\n\n          case 8:\n            if (!(params.blockTag && isHexString(params.blockTag))) {\n              _context2.next = 12;\n              break;\n            }\n\n            _context2.next = 11;\n            return waitForSync(config, currentBlockNumber);\n\n          case 11:\n            provider = _context2.sent;\n\n          case 12:\n            return _context2.abrupt(\"return\", provider[method](params.address, params.blockTag || \"latest\"));\n\n          case 13:\n            if (!(params.blockTag && isHexString(params.blockTag))) {\n              _context2.next = 17;\n              break;\n            }\n\n            _context2.next = 16;\n            return waitForSync(config, currentBlockNumber);\n\n          case 16:\n            provider = _context2.sent;\n\n          case 17:\n            return _context2.abrupt(\"return\", provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\"));\n\n          case 18:\n            if (!(params.blockTag && isHexString(params.blockTag))) {\n              _context2.next = 22;\n              break;\n            }\n\n            _context2.next = 21;\n            return waitForSync(config, currentBlockNumber);\n\n          case 21:\n            provider = _context2.sent;\n\n          case 22:\n            return _context2.abrupt(\"return\", provider[params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\"](params.blockTag || params.blockHash));\n\n          case 23:\n            if (!(params.blockTag && isHexString(params.blockTag))) {\n              _context2.next = 27;\n              break;\n            }\n\n            _context2.next = 26;\n            return waitForSync(config, currentBlockNumber);\n\n          case 26:\n            provider = _context2.sent;\n\n          case 27:\n            return _context2.abrupt(\"return\", provider[method](params.transaction));\n\n          case 28:\n            return _context2.abrupt(\"return\", provider[method](params.transactionHash));\n\n          case 29:\n            filter = params.filter;\n\n            if (!(filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock))) {\n              _context2.next = 34;\n              break;\n            }\n\n            _context2.next = 33;\n            return waitForSync(config, currentBlockNumber);\n\n          case 33:\n            provider = _context2.sent;\n\n          case 34:\n            return _context2.abrupt(\"return\", provider.getLogs(filter));\n\n          case 35:\n            return _context2.abrupt(\"return\", logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n              method: method,\n              params: params\n            }));\n\n          case 36:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n\nexport var FallbackProvider = /*#__PURE__*/function (_BaseProvider) {\n  _inherits(FallbackProvider, _BaseProvider);\n\n  var _super = _createSuper(FallbackProvider);\n\n  function FallbackProvider(providers, quorum) {\n    var _this;\n\n    _classCallCheck(this, FallbackProvider);\n\n    if (providers.length === 0) {\n      logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n    }\n\n    var providerConfigs = providers.map(function (configOrProvider, index) {\n      if (Provider.isProvider(configOrProvider)) {\n        var stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n        var priority = 1;\n        return Object.freeze({\n          provider: configOrProvider,\n          weight: 1,\n          stallTimeout: stallTimeout,\n          priority: priority\n        });\n      }\n\n      var config = shallowCopy(configOrProvider);\n\n      if (config.priority == null) {\n        config.priority = 1;\n      }\n\n      if (config.stallTimeout == null) {\n        config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n      }\n\n      if (config.weight == null) {\n        config.weight = 1;\n      }\n\n      var weight = config.weight;\n\n      if (weight % 1 || weight > 512 || weight < 1) {\n        logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", \"providers[\".concat(index, \"].weight\"), weight);\n      }\n\n      return Object.freeze(config);\n    });\n    var total = providerConfigs.reduce(function (accum, c) {\n      return accum + c.weight;\n    }, 0);\n\n    if (quorum == null) {\n      quorum = total / 2;\n    } else if (quorum > total) {\n      logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n    } // Are all providers' networks are known\n\n\n    var networkOrReady = checkNetworks(providerConfigs.map(function (c) {\n      return c.provider.network;\n    })); // Not all networks are known; we must stall\n\n    if (networkOrReady == null) {\n      networkOrReady = new Promise(function (resolve, reject) {\n        setTimeout(function () {\n          _this.detectNetwork().then(resolve, reject);\n        }, 0);\n      });\n    }\n\n    _this = _super.call(this, networkOrReady); // Preserve a copy, so we do not get mutated\n\n    defineReadOnly(_assertThisInitialized(_this), \"providerConfigs\", Object.freeze(providerConfigs));\n    defineReadOnly(_assertThisInitialized(_this), \"quorum\", quorum);\n    _this._highestBlockNumber = -1;\n    return _this;\n  }\n\n  _createClass(FallbackProvider, [{\n    key: \"detectNetwork\",\n    value: function detectNetwork() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var networks;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return Promise.all(this.providerConfigs.map(function (c) {\n                  return c.provider.getNetwork();\n                }));\n\n              case 2:\n                networks = _context3.sent;\n                return _context3.abrupt(\"return\", checkNetworks(networks));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"perform\",\n    value: function perform(method, params) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this2 = this;\n\n        var results, _i, result, processFunc, configs, currentBlockNumber, i, first, _loop, _ret;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(method === \"sendTransaction\")) {\n                  _context5.next = 13;\n                  break;\n                }\n\n                _context5.next = 3;\n                return Promise.all(this.providerConfigs.map(function (c) {\n                  return c.provider.sendTransaction(params.signedTransaction).then(function (result) {\n                    return result.hash;\n                  }, function (error) {\n                    return error;\n                  });\n                }));\n\n              case 3:\n                results = _context5.sent;\n                _i = 0;\n\n              case 5:\n                if (!(_i < results.length)) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                result = results[_i];\n\n                if (!(typeof result === \"string\")) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", result);\n\n              case 9:\n                _i++;\n                _context5.next = 5;\n                break;\n\n              case 12:\n                throw results[0];\n\n              case 13:\n                if (!(this._highestBlockNumber === -1 && method !== \"getBlockNumber\")) {\n                  _context5.next = 16;\n                  break;\n                }\n\n                _context5.next = 16;\n                return this.getBlockNumber();\n\n              case 16:\n                processFunc = getProcessFunc(this, method, params); // Shuffle the providers and then sort them by their priority; we\n                // shallowCopy them since we will store the result in them too\n\n                configs = shuffled(this.providerConfigs.map(shallowCopy));\n                configs.sort(function (a, b) {\n                  return a.priority - b.priority;\n                });\n                currentBlockNumber = this._highestBlockNumber;\n                i = 0;\n                first = true;\n                _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                  var t0, inflightWeight, _loop2, waiting, results, _result, errors;\n\n                  return _regeneratorRuntime().wrap(function _loop$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          t0 = now(); // Compute the inflight weight (exclude anything past)\n\n                          inflightWeight = configs.filter(function (c) {\n                            return c.runner && t0 - c.start < c.stallTimeout;\n                          }).reduce(function (accum, c) {\n                            return accum + c.weight;\n                          }, 0); // Start running enough to meet quorum\n\n                          _loop2 = function _loop2() {\n                            var config = configs[i++];\n                            var rid = nextRid++;\n                            config.start = now();\n                            config.staller = stall(config.stallTimeout);\n                            config.staller.wait(function () {\n                              config.staller = null;\n                            });\n                            config.runner = getRunner(config, currentBlockNumber, method, params).then(function (result) {\n                              config.done = true;\n                              config.result = result;\n\n                              if (_this2.listenerCount(\"debug\")) {\n                                _this2.emit(\"debug\", {\n                                  action: \"request\",\n                                  rid: rid,\n                                  backend: exposeDebugConfig(config, now()),\n                                  request: {\n                                    method: method,\n                                    params: deepCopy(params)\n                                  },\n                                  provider: _this2\n                                });\n                              }\n                            }, function (error) {\n                              config.done = true;\n                              config.error = error;\n\n                              if (_this2.listenerCount(\"debug\")) {\n                                _this2.emit(\"debug\", {\n                                  action: \"request\",\n                                  rid: rid,\n                                  backend: exposeDebugConfig(config, now()),\n                                  request: {\n                                    method: method,\n                                    params: deepCopy(params)\n                                  },\n                                  provider: _this2\n                                });\n                              }\n                            });\n\n                            if (_this2.listenerCount(\"debug\")) {\n                              _this2.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, null),\n                                request: {\n                                  method: method,\n                                  params: deepCopy(params)\n                                },\n                                provider: _this2\n                              });\n                            }\n\n                            inflightWeight += config.weight;\n                          };\n\n                          while (inflightWeight < _this2.quorum && i < configs.length) {\n                            _loop2();\n                          } // Wait for anything meaningful to finish or stall out\n\n\n                          waiting = [];\n                          configs.forEach(function (c) {\n                            if (c.done || !c.runner) {\n                              return;\n                            }\n\n                            waiting.push(c.runner);\n\n                            if (c.staller) {\n                              waiting.push(c.staller.getPromise());\n                            }\n                          });\n\n                          if (!waiting.length) {\n                            _context4.next = 9;\n                            break;\n                          }\n\n                          _context4.next = 9;\n                          return Promise.race(waiting);\n\n                        case 9:\n                          // Check the quorum and process the results; the process function\n                          // may additionally decide the quorum is not met\n                          results = configs.filter(function (c) {\n                            return c.done && c.error == null;\n                          });\n\n                          if (!(results.length >= _this2.quorum)) {\n                            _context4.next = 19;\n                            break;\n                          }\n\n                          _result = processFunc(results);\n\n                          if (!(_result !== undefined)) {\n                            _context4.next = 15;\n                            break;\n                          }\n\n                          // Shut down any stallers\n                          configs.forEach(function (c) {\n                            if (c.staller) {\n                              c.staller.cancel();\n                            }\n\n                            c.cancelled = true;\n                          });\n                          return _context4.abrupt(\"return\", {\n                            v: _result\n                          });\n\n                        case 15:\n                          if (first) {\n                            _context4.next = 18;\n                            break;\n                          }\n\n                          _context4.next = 18;\n                          return stall(100).getPromise();\n\n                        case 18:\n                          first = false;\n\n                        case 19:\n                          // No result, check for errors that should be forwarded\n                          errors = configs.reduce(function (accum, c) {\n                            if (!c.done || c.error == null) {\n                              return accum;\n                            }\n\n                            var code = c.error.code;\n\n                            if (ForwardErrors.indexOf(code) >= 0) {\n                              if (!accum[code]) {\n                                accum[code] = {\n                                  error: c.error,\n                                  weight: 0\n                                };\n                              }\n\n                              accum[code].weight += c.weight;\n                            }\n\n                            return accum;\n                          }, {});\n                          Object.keys(errors).forEach(function (errorCode) {\n                            var tally = errors[errorCode];\n\n                            if (tally.weight < _this2.quorum) {\n                              return;\n                            } // Shut down any stallers\n\n\n                            configs.forEach(function (c) {\n                              if (c.staller) {\n                                c.staller.cancel();\n                              }\n\n                              c.cancelled = true;\n                            });\n                            var e = tally.error;\n                            var props = {};\n                            ForwardProperties.forEach(function (name) {\n                              if (e[name] == null) {\n                                return;\n                              }\n\n                              props[name] = e[name];\n                            });\n                            logger.throwError(e.reason || e.message, errorCode, props);\n                          }); // All configs have run to completion; we will never get more data\n\n                          if (!(configs.filter(function (c) {\n                            return !c.done;\n                          }).length === 0)) {\n                            _context4.next = 23;\n                            break;\n                          }\n\n                          return _context4.abrupt(\"return\", \"break\");\n\n                        case 23:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _loop);\n                });\n\n              case 23:\n                if (!true) {\n                  _context5.next = 32;\n                  break;\n                }\n\n                return _context5.delegateYield(_loop(), \"t0\", 25);\n\n              case 25:\n                _ret = _context5.t0;\n\n                if (!(_ret === \"break\")) {\n                  _context5.next = 28;\n                  break;\n                }\n\n                return _context5.abrupt(\"break\", 32);\n\n              case 28:\n                if (!(typeof _ret === \"object\")) {\n                  _context5.next = 30;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", _ret.v);\n\n              case 30:\n                _context5.next = 23;\n                break;\n\n              case 32:\n                // Shut down any stallers; shouldn't be any\n                configs.forEach(function (c) {\n                  if (c.staller) {\n                    c.staller.cancel();\n                  }\n\n                  c.cancelled = true;\n                });\n                return _context5.abrupt(\"return\", logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                  method: method,\n                  params: params,\n                  //results: configs.map((c) => c.result),\n                  //errors: configs.map((c) => c.error),\n                  results: configs.map(function (c) {\n                    return exposeDebugConfig(c);\n                  }),\n                  provider: this\n                }));\n\n              case 34:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }]);\n\n  return FallbackProvider;\n}(BaseProvider);","map":{"version":3,"mappings":"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","names":["Provider","BigNumber","isHexString","deepCopy","defineReadOnly","shallowCopy","shuffled","poll","BaseProvider","isCommunityResource","Logger","version","logger","now","Date","getTime","checkNetworks","networks","result","i","length","network","name","chainId","ensAddress","throwArgumentError","median","values","maxDelta","slice","sort","middle","Math","floor","a","b","abs","serialize","value","JSON","stringify","isBigNumber","toString","Array","isArray","map","keys","Object","key","v","join","Error","nextRid","stall","duration","cancel","timer","promise","Promise","resolve","clearTimeout","setTimeout","wait","func","then","getPromise","ForwardErrors","errors","CALL_EXCEPTION","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","UNPREDICTABLE_GAS_LIMIT","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","get","provider","start","done","error","normalizedTally","normalize","quorum","configs","tally","forEach","c","count","check","undefined","getProcessFunc","method","params","blockNumber","ceil","indexOf","_highestBlockNumber","tx","confirmations","includeTransactions","block","transactions","waitForSync","reject","cancelled","oncePoll","getRunner","currentBlockNumber","getEtherPrice","blockTag","address","getStorageAt","position","blockHash","transaction","transactionHash","filter","fromBlock","toBlock","getLogs","throwError","UNKNOWN_ERROR","FallbackProvider","providers","providerConfigs","configOrProvider","index","isProvider","stallTimeout","priority","freeze","total","reduce","accum","networkOrReady","detectNetwork","all","getNetwork","sendTransaction","signedTransaction","hash","results","getBlockNumber","processFunc","first","t0","inflightWeight","runner","rid","staller","listenerCount","emit","action","backend","request","waiting","push","race","code","errorCode","e","props","reason","message","SERVER_ERROR"],"sources":["C:\\Users\\kiril\\Desktop\\newenvai\\client\\node_modules\\@ethersproject\\providers\\src.ts\\fallback-provider.ts"],"sourcesContent":["\"use strict\";\n\nimport { Block, BlockWithTransactions, Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\n\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() { return (new Date()).getTime(); }\n\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks: Array<Network>): Network {\n    let result = null;\n\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n\n        // Null! We do not know our network; bail.\n        if (network == null) { return null; }\n\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n           }\n        } else {\n            result = network;\n        }\n    }\n\n    return result;\n}\n\nfunction median(values: Array<number>, maxDelta?: number): number {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n\n    return (a + b) / 2;\n}\n\nfunction serialize(value: any): string {\n    if (value === null) {\n        return \"null\";\n    } else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return JSON.stringify(value);\n    } else if (typeof(value) === \"string\") {\n        return value;\n    } else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    } else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    } else if (typeof(value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof(v) === \"function\") {\n                v = \"[function]\";\n            } else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n\n    throw new Error(\"unknown value type: \" + typeof(value));\n}\n\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n\n\nexport interface FallbackProviderConfig {\n    // The Provider\n    provider: Provider;\n\n    // The priority to favour this Provider; lower values are used first (higher priority)\n    priority?: number;\n\n    // Timeout before also triggering the next provider; this does not stop\n    // this provider and if its result comes back before a quorum is reached\n    // it will be incorporated into the vote\n    // - lower values will cause more network traffic but may result in a\n    //   faster result.\n    stallTimeout?: number;\n\n    // How much this provider contributes to the quorum; sometimes a specific\n    // provider may be more reliable or trustworthy than others, but usually\n    // this should be left as the default\n    weight?: number;\n};\n\n// A Staller is used to provide a delay to give a Provider a chance to response\n// before asking the next Provider to try.\ntype Staller = {\n    wait: (func: () => void) => Promise<void>\n    getPromise: () => Promise<void>,\n    cancel: () => void\n};\n\nfunction stall(duration: number): Staller {\n    let cancel: () => void = null;\n\n    let timer: NodeJS.Timer = null;\n    let promise = <Promise<void>>(new Promise((resolve) => {\n        cancel = function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        }\n        timer = setTimeout(cancel, duration);\n    }));\n\n    const wait = (func: () => void) => {\n        promise = promise.then(func);\n        return promise;\n    }\n\n    function getPromise(): Promise<void> {\n        return promise;\n    }\n\n    return { cancel, getPromise, wait };\n}\n\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\n\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n\n\n// @TODO: Make this an object with staller and cancel built-in\ninterface RunningConfig extends FallbackProviderConfig {\n    start?: number;\n    done?: boolean;\n    cancelled?: boolean;\n    runner?: Promise<any>;\n    staller?: Staller;\n    result?: any;\n    error?: Error;\n};\n\nfunction exposeDebugConfig(config: RunningConfig, now?: number): any {\n    const result: any = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) { result.start = config.start; }\n    if (now) { result.duration = (now - config.start); }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        } else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\n\nfunction normalizedTally(normalize: (value: any) => string, quorum: number): (configs: Array<RunningConfig>) => any {\n    return function(configs: Array<RunningConfig>): any {\n\n        // Count the votes for each result\n        const tally: { [ key: string]: { count: number, result: any } } = { };\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) { tally[value] = { count: 0, result: c.result }; }\n            tally[value].count++;\n        });\n\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n\n        // No quroum\n        return undefined;\n    }\n}\nfunction getProcessFunc(provider: FallbackProvider, method: string, params: { [ key: string ]: any }): (configs: Array<RunningConfig>) => any {\n\n    let normalize = serialize;\n\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function(configs: Array<RunningConfig>): number {\n                const values = configs.map((c) => c.result);\n\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) { return undefined; }\n\n                blockNumber = Math.ceil(blockNumber);\n\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) { blockNumber++; }\n\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n\n                return provider._highestBlockNumber;\n            };\n\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function(configs: Array<RunningConfig>): BigNumber {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            }\n\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function(configs: Array<RunningConfig>): number {\n                return median(configs.map((c) => c.result));\n            }\n\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function(tx: any): string {\n                if (tx == null) { return null; }\n\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            }\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function(block: BlockWithTransactions): string {\n                    if (block == null) { return null; }\n\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            } else {\n                normalize = function(block: Block): string {\n                    if (block == null) { return null; }\n                    return serialize(block);\n                }\n            }\n            break;\n\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n\n}\n\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nasync function waitForSync(config: RunningConfig, blockNumber: number): Promise<BaseProvider> {\n    const provider = <BaseProvider>(config.provider);\n\n    if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n        return provider;\n    }\n\n    return poll(() => {\n        return new Promise((resolve, reject) => {\n            setTimeout(function() {\n\n                // We are synced\n                if (provider.blockNumber >= blockNumber) { return resolve(provider); }\n\n                // We're done; just quit\n                if (config.cancelled) { return resolve(null); }\n\n                // Try again, next block\n                return resolve(undefined);\n            }, 0);\n        });\n    }, { oncePoll: provider });\n}\n\nasync function getRunner(config: RunningConfig, currentBlockNumber: number, method: string, params: { [ key: string]: any }): Promise<any> {\n    let provider = config.provider;\n\n    switch (method) {\n        case \"getBlockNumber\":\n        case \"getGasPrice\":\n            return provider[method]();\n        case \"getEtherPrice\":\n            if ((<any>provider).getEtherPrice) {\n                return (<any>provider).getEtherPrice();\n            }\n            break;\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.address, params.blockTag || \"latest\");\n        case \"getStorageAt\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n        case \"getBlock\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\": \"getBlock\")](params.blockTag || params.blockHash);\n        case \"call\":\n        case \"estimateGas\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.transaction);\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            return provider[method](params.transactionHash);\n        case \"getLogs\": {\n            let filter = params.filter;\n            if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n        method: method,\n        params: params\n    });\n}\n\nexport class FallbackProvider extends BaseProvider {\n    readonly providerConfigs: ReadonlyArray<FallbackProviderConfig>;\n    readonly quorum: number;\n\n    // Due to the highly asyncronous nature of the blockchain, we need\n    // to make sure we never unroll the blockNumber due to our random\n    // sample of backends\n    _highestBlockNumber: number;\n\n    constructor(providers: Array<Provider | FallbackProviderConfig>, quorum?: number) {\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n\n        const providerConfigs: Array<FallbackProviderConfig> = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n\n            const config: FallbackProviderConfig = shallowCopy(configOrProvider);\n\n            if (config.priority == null) { config.priority = 1; }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n            }\n            if (config.weight == null) { config.weight = 1; }\n\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${ index }].weight`, weight);\n            }\n\n            return Object.freeze(config);\n        });\n\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n\n        if (quorum == null) {\n            quorum = total / 2;\n        } else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n\n        // Are all providers' networks are known\n        let networkOrReady: Network | Promise<Network> = checkNetworks(providerConfigs.map((c) => (<any>(c.provider)).network));\n\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n\n        this._highestBlockNumber = -1;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        const networks = await Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n        return checkNetworks(networks);\n    }\n\n    async perform(method: string, params: { [name: string]: any }): Promise<any> {\n        // Sending transactions is special; always broadcast it to all backends\n        if (method === \"sendTransaction\") {\n            const results: Array<string | Error> = await Promise.all(this.providerConfigs.map((c) => {\n                return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                    return result.hash;\n                }, (error) => {\n                    return error;\n                });\n            }));\n\n            // Any success is good enough (other errors are likely \"already seen\" errors\n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (typeof(result) === \"string\") { return result; }\n            }\n\n            // They were all an error; pick the first error\n            throw results[0];\n        }\n\n        // We need to make sure we are in sync with our backends, so we need\n        // to know this before we can make a lot of calls\n        if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n            await this.getBlockNumber();\n        }\n\n        const processFunc = getProcessFunc(this, method, params);\n\n        // Shuffle the providers and then sort them by their priority; we\n        // shallowCopy them since we will store the result in them too\n        const configs: Array<RunningConfig> = shuffled(this.providerConfigs.map(shallowCopy));\n        configs.sort((a, b) => (a.priority - b.priority));\n\n        const currentBlockNumber = this._highestBlockNumber;\n\n        let i = 0;\n        let first = true;\n        while (true) {\n            const t0 = now();\n\n            // Compute the inflight weight (exclude anything past)\n            let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                                        .reduce((accum, c) => (accum + c.weight), 0);\n\n            // Start running enough to meet quorum\n            while (inflightWeight < this.quorum && i < configs.length) {\n                const config = configs[i++];\n\n                const rid = nextRid++;\n\n                config.start = now();\n                config.staller = stall(config.stallTimeout);\n                config.staller.wait(() => { config.staller = null; });\n\n                config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                    config.done = true;\n                    config.result = result;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                     }\n\n                }, (error) => {\n                    config.done = true;\n                    config.error = error;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                });\n\n                if (this.listenerCount(\"debug\")) {\n                    this.emit(\"debug\", {\n                        action: \"request\",\n                        rid: rid,\n                        backend: exposeDebugConfig(config, null),\n                        request: { method: method, params: deepCopy(params) },\n                        provider: this\n                    });\n                }\n\n                inflightWeight += config.weight;\n            }\n\n            // Wait for anything meaningful to finish or stall out\n            const waiting: Array<Promise<any>> = [ ];\n            configs.forEach((c) => {\n                if (c.done || !c.runner) { return; }\n                waiting.push(c.runner);\n                if (c.staller) { waiting.push(c.staller.getPromise()); }\n            });\n\n            if (waiting.length) { await Promise.race(waiting); }\n\n            // Check the quorum and process the results; the process function\n            // may additionally decide the quorum is not met\n            const results = configs.filter((c) => (c.done && c.error == null));\n            if (results.length >= this.quorum) {\n                const result = processFunc(results);\n                if (result !== undefined) {\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) { c.staller.cancel(); }\n                        c.cancelled = true;\n                    });\n                    return result;\n                }\n                if (!first) { await stall(100).getPromise(); }\n                first = false;\n            }\n\n            // No result, check for errors that should be forwarded\n            const errors = configs.reduce((accum, c) => {\n                if (!c.done || c.error == null) { return accum; }\n\n                const code = (<any>(c.error)).code;\n                if (ForwardErrors.indexOf(code) >= 0) {\n                    if (!accum[code]) { accum[code] = { error: c.error, weight: 0 }; }\n                    accum[code].weight += c.weight;\n                }\n\n                return accum;\n            }, <{ [ code: string ]: { error: Error, weight: number } }>({ }));\n\n            Object.keys(errors).forEach((errorCode: string) => {\n                const tally = errors[errorCode];\n                if (tally.weight < this.quorum) { return; }\n\n                // Shut down any stallers\n                configs.forEach(c => {\n                    if (c.staller) { c.staller.cancel(); }\n                    c.cancelled = true;\n                });\n\n                const e = <any>(tally.error);\n\n                const props: { [ name: string ]: any } = { };\n                ForwardProperties.forEach((name) => {\n                    if (e[name] == null) { return; }\n                    props[name] = e[name];\n                });\n\n                logger.throwError(e.reason || e.message, <any>errorCode, props);\n            });\n\n            // All configs have run to completion; we will never get more data\n            if (configs.filter((c) => !c.done).length === 0) { break; }\n        }\n\n        // Shut down any stallers; shouldn't be any\n        configs.forEach(c => {\n            if (c.staller) { c.staller.cancel(); }\n            c.cancelled = true;\n        });\n\n        return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n            method: method,\n            params: params,\n            //results: configs.map((c) => c.result),\n            //errors: configs.map((c) => c.error),\n            results: configs.map((c) => exposeDebugConfig(c)),\n            provider: this\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}