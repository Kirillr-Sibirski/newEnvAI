{"ast":null,"code":"import _classCallCheck from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\"; // Experimental\n\nexport var JsonRpcBatchProvider = /*#__PURE__*/function (_JsonRpcProvider) {\n  _inherits(JsonRpcBatchProvider, _JsonRpcProvider);\n\n  var _super = _createSuper(JsonRpcBatchProvider);\n\n  function JsonRpcBatchProvider() {\n    _classCallCheck(this, JsonRpcBatchProvider);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(JsonRpcBatchProvider, [{\n    key: \"send\",\n    value: function send(method, params) {\n      var _this = this;\n\n      var request = {\n        method: method,\n        params: params,\n        id: this._nextId++,\n        jsonrpc: \"2.0\"\n      };\n\n      if (this._pendingBatch == null) {\n        this._pendingBatch = [];\n      }\n\n      var inflightRequest = {\n        request: request,\n        resolve: null,\n        reject: null\n      };\n      var promise = new Promise(function (resolve, reject) {\n        inflightRequest.resolve = resolve;\n        inflightRequest.reject = reject;\n      });\n\n      this._pendingBatch.push(inflightRequest);\n\n      if (!this._pendingBatchAggregator) {\n        // Schedule batch for next event loop + short duration\n        this._pendingBatchAggregator = setTimeout(function () {\n          // Get teh current batch and clear it, so new requests\n          // go into the next batch\n          var batch = _this._pendingBatch;\n          _this._pendingBatch = null;\n          _this._pendingBatchAggregator = null; // Get the request as an array of requests\n\n          var request = batch.map(function (inflight) {\n            return inflight.request;\n          });\n\n          _this.emit(\"debug\", {\n            action: \"requestBatch\",\n            request: deepCopy(request),\n            provider: _this\n          });\n\n          return fetchJson(_this.connection, JSON.stringify(request)).then(function (result) {\n            _this.emit(\"debug\", {\n              action: \"response\",\n              request: request,\n              response: result,\n              provider: _this\n            }); // For each result, feed it to the correct Promise, depending\n            // on whether it was a success or error\n\n\n            batch.forEach(function (inflightRequest, index) {\n              var payload = result[index];\n\n              if (payload.error) {\n                var error = new Error(payload.error.message);\n                error.code = payload.error.code;\n                error.data = payload.error.data;\n                inflightRequest.reject(error);\n              } else {\n                inflightRequest.resolve(payload.result);\n              }\n            });\n          }, function (error) {\n            _this.emit(\"debug\", {\n              action: \"response\",\n              error: error,\n              request: request,\n              provider: _this\n            });\n\n            batch.forEach(function (inflightRequest) {\n              inflightRequest.reject(error);\n            });\n          });\n        }, 10);\n      }\n\n      return promise;\n    }\n  }]);\n\n  return JsonRpcBatchProvider;\n}(JsonRpcProvider);","map":{"version":3,"mappings":"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","names":["deepCopy","fetchJson","JsonRpcProvider","JsonRpcBatchProvider","method","params","request","id","_nextId","jsonrpc","_pendingBatch","inflightRequest","resolve","reject","promise","Promise","push","_pendingBatchAggregator","setTimeout","batch","map","inflight","emit","action","provider","connection","JSON","stringify","then","result","response","forEach","index","payload","error","Error","message","code","data"],"sources":["C:\\Users\\kiril\\Desktop\\newenvai\\client\\node_modules\\@ethersproject\\providers\\src.ts\\json-rpc-batch-provider.ts"],"sourcesContent":["\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Experimental\n\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    _pendingBatchAggregator: NodeJS.Timer;\n    _pendingBatch: Array<{\n        request: { method: string, params: Array<any>, id: number, jsonrpc: \"2.0\" },\n        resolve: (result: any) => void,\n        reject: (error: Error) => void\n    }>;\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [ ];\n        }\n\n        const inflightRequest: any = { request, resolve: null, reject: null };\n\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n\n        this._pendingBatch.push(inflightRequest);\n\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            (<any>error).code = payload.error.code;\n                            (<any>error).data = payload.error.data;\n                            inflightRequest.reject(error);\n                        } else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n\n            }, 10);\n        }\n\n        return promise;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}