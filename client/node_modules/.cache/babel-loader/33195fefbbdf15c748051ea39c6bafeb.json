{"ast":null,"code":"\"use strict\";\n\nimport _regeneratorRuntime from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/kiril/Desktop/newenvai/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport aes from \"aes-js\";\nimport scrypt from \"scrypt-js\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { defaultPath, entropyToMnemonic, HDNode, mnemonicToEntropy } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { Description } from \"@ethersproject/properties\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { getPassword, looseArrayify, searchPath, uuidV4, zpad } from \"./utils\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version); // Exported Types\n\nfunction hasMnemonic(value) {\n  return value != null && value.mnemonic && value.mnemonic.phrase;\n}\n\nexport var KeystoreAccount = /*#__PURE__*/function (_Description) {\n  _inherits(KeystoreAccount, _Description);\n\n  var _super = _createSuper(KeystoreAccount);\n\n  function KeystoreAccount() {\n    _classCallCheck(this, KeystoreAccount);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(KeystoreAccount, [{\n    key: \"isKeystoreAccount\",\n    value: function isKeystoreAccount(value) {\n      return !!(value && value._isKeystoreAccount);\n    }\n  }]);\n\n  return KeystoreAccount;\n}(Description);\n\nfunction _decrypt(data, key, ciphertext) {\n  var cipher = searchPath(data, \"crypto/cipher\");\n\n  if (cipher === \"aes-128-ctr\") {\n    var iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"));\n    var counter = new aes.Counter(iv);\n    var aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n    return arrayify(aesCtr.decrypt(ciphertext));\n  }\n\n  return null;\n}\n\nfunction _getAccount(data, key) {\n  var ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\n  var computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);\n\n  if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\n    throw new Error(\"invalid password\");\n  }\n\n  var privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n\n  if (!privateKey) {\n    logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\n      operation: \"decrypt\"\n    });\n  }\n\n  var mnemonicKey = key.slice(32, 64);\n  var address = computeAddress(privateKey);\n\n  if (data.address) {\n    var check = data.address.toLowerCase();\n\n    if (check.substring(0, 2) !== \"0x\") {\n      check = \"0x\" + check;\n    }\n\n    if (getAddress(check) !== address) {\n      throw new Error(\"address mismatch\");\n    }\n  }\n\n  var account = {\n    _isKeystoreAccount: true,\n    address: address,\n    privateKey: hexlify(privateKey)\n  }; // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n\n  if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\n    var mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n    var mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\n    var mnemonicCounter = new aes.Counter(mnemonicIv);\n    var mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n    var path = searchPath(data, \"x-ethers/path\") || defaultPath;\n    var locale = searchPath(data, \"x-ethers/locale\") || \"en\";\n    var entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n\n    try {\n      var mnemonic = entropyToMnemonic(entropy, locale);\n      var node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n\n      if (node.privateKey != account.privateKey) {\n        throw new Error(\"mnemonic mismatch\");\n      }\n\n      account.mnemonic = node.mnemonic;\n    } catch (error) {\n      // If we don't have the locale wordlist installed to\n      // read this mnemonic, just bail and don't set the\n      // mnemonic\n      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n        throw error;\n      }\n    }\n  }\n\n  return new KeystoreAccount(account);\n}\n\nfunction pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {\n  return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {\n  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {\n  var passwordBytes = getPassword(password);\n  var kdf = searchPath(data, \"crypto/kdf\");\n\n  if (kdf && typeof kdf === \"string\") {\n    var throwError = function throwError(name, value) {\n      return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n    };\n\n    if (kdf.toLowerCase() === \"scrypt\") {\n      var salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n      var N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\n      var r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\n      var p = parseInt(searchPath(data, \"crypto/kdfparams/p\")); // Check for all required parameters\n\n      if (!N || !r || !p) {\n        throwError(\"kdf\", kdf);\n      } // Make sure N is a power of 2\n\n\n      if ((N & N - 1) !== 0) {\n        throwError(\"N\", N);\n      }\n\n      var dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n\n      if (dkLen !== 32) {\n        throwError(\"dklen\", dkLen);\n      }\n\n      return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n    } else if (kdf.toLowerCase() === \"pbkdf2\") {\n      var _salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n\n      var prfFunc = null;\n      var prf = searchPath(data, \"crypto/kdfparams/prf\");\n\n      if (prf === \"hmac-sha256\") {\n        prfFunc = \"sha256\";\n      } else if (prf === \"hmac-sha512\") {\n        prfFunc = \"sha512\";\n      } else {\n        throwError(\"prf\", prf);\n      }\n\n      var count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\n\n      var _dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n\n      if (_dkLen !== 32) {\n        throwError(\"dklen\", _dkLen);\n      }\n\n      return pbkdf2Func(passwordBytes, _salt, count, _dkLen, prfFunc);\n    }\n  }\n\n  return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n}\n\nexport function decryptSync(json, password) {\n  var data = JSON.parse(json);\n\n  var key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\n\n  return _getAccount(data, key);\n}\nexport function decrypt(json, password, progressCallback) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var data, key;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            data = JSON.parse(json);\n            _context.next = 3;\n            return _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\n\n          case 3:\n            key = _context.sent;\n            return _context.abrupt(\"return\", _getAccount(data, key));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\nexport function encrypt(account, password, options, progressCallback) {\n  try {\n    // Check the address matches the private key\n    if (getAddress(account.address) !== computeAddress(account.privateKey)) {\n      throw new Error(\"address/privateKey mismatch\");\n    } // Check the mnemonic (if any) matches the private key\n\n\n    if (hasMnemonic(account)) {\n      var mnemonic = account.mnemonic;\n      var node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\n\n      if (node.privateKey != account.privateKey) {\n        throw new Error(\"mnemonic mismatch\");\n      }\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  } // The options are optional, so adjust the call as needed\n\n\n  if (typeof options === \"function\" && !progressCallback) {\n    progressCallback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  var privateKey = arrayify(account.privateKey);\n  var passwordBytes = getPassword(password);\n  var entropy = null;\n  var path = null;\n  var locale = null;\n\n  if (hasMnemonic(account)) {\n    var srcMnemonic = account.mnemonic;\n    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n    path = srcMnemonic.path || defaultPath;\n    locale = srcMnemonic.locale || \"en\";\n  }\n\n  var client = options.client;\n\n  if (!client) {\n    client = \"ethers.js\";\n  } // Check/generate the salt\n\n\n  var salt = null;\n\n  if (options.salt) {\n    salt = arrayify(options.salt);\n  } else {\n    salt = randomBytes(32);\n    ;\n  } // Override initialization vector\n\n\n  var iv = null;\n\n  if (options.iv) {\n    iv = arrayify(options.iv);\n\n    if (iv.length !== 16) {\n      throw new Error(\"invalid iv\");\n    }\n  } else {\n    iv = randomBytes(16);\n  } // Override the uuid\n\n\n  var uuidRandom = null;\n\n  if (options.uuid) {\n    uuidRandom = arrayify(options.uuid);\n\n    if (uuidRandom.length !== 16) {\n      throw new Error(\"invalid uuid\");\n    }\n  } else {\n    uuidRandom = randomBytes(16);\n  } // Override the scrypt password-based key derivation function parameters\n\n\n  var N = 1 << 17,\n      r = 8,\n      p = 1;\n\n  if (options.scrypt) {\n    if (options.scrypt.N) {\n      N = options.scrypt.N;\n    }\n\n    if (options.scrypt.r) {\n      r = options.scrypt.r;\n    }\n\n    if (options.scrypt.p) {\n      p = options.scrypt.p;\n    }\n  } // We take 64 bytes:\n  //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n  //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n\n\n  return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(function (key) {\n    key = arrayify(key); // This will be used to encrypt the wallet (as per Web3 secret storage)\n\n    var derivedKey = key.slice(0, 16);\n    var macPrefix = key.slice(16, 32); // This will be used to encrypt the mnemonic phrase (if any)\n\n    var mnemonicKey = key.slice(32, 64); // Encrypt the private key\n\n    var counter = new aes.Counter(iv);\n    var aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n    var ciphertext = arrayify(aesCtr.encrypt(privateKey)); // Compute the message authentication code, used to check the password\n\n    var mac = keccak256(concat([macPrefix, ciphertext])); // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n\n    var data = {\n      address: account.address.substring(2).toLowerCase(),\n      id: uuidV4(uuidRandom),\n      version: 3,\n      Crypto: {\n        cipher: \"aes-128-ctr\",\n        cipherparams: {\n          iv: hexlify(iv).substring(2)\n        },\n        ciphertext: hexlify(ciphertext).substring(2),\n        kdf: \"scrypt\",\n        kdfparams: {\n          salt: hexlify(salt).substring(2),\n          n: N,\n          dklen: 32,\n          p: p,\n          r: r\n        },\n        mac: mac.substring(2)\n      }\n    }; // If we have a mnemonic, encrypt it into the JSON wallet\n\n    if (entropy) {\n      var mnemonicIv = randomBytes(16);\n      var mnemonicCounter = new aes.Counter(mnemonicIv);\n      var mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n      var mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\n      var now = new Date();\n      var timestamp = now.getUTCFullYear() + \"-\" + zpad(now.getUTCMonth() + 1, 2) + \"-\" + zpad(now.getUTCDate(), 2) + \"T\" + zpad(now.getUTCHours(), 2) + \"-\" + zpad(now.getUTCMinutes(), 2) + \"-\" + zpad(now.getUTCSeconds(), 2) + \".0Z\";\n      data[\"x-ethers\"] = {\n        client: client,\n        gethFilename: \"UTC--\" + timestamp + \"--\" + data.address,\n        mnemonicCounter: hexlify(mnemonicIv).substring(2),\n        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n        path: path,\n        locale: locale,\n        version: \"0.1\"\n      };\n    }\n\n    return JSON.stringify(data);\n  });\n}","map":{"version":3,"mappings":"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","names":["aes","scrypt","getAddress","arrayify","concat","hexlify","defaultPath","entropyToMnemonic","HDNode","mnemonicToEntropy","keccak256","pbkdf2","_pbkdf2","randomBytes","Description","computeAddress","getPassword","looseArrayify","searchPath","uuidV4","zpad","Logger","version","logger","hasMnemonic","value","mnemonic","phrase","KeystoreAccount","_isKeystoreAccount","_decrypt","data","key","ciphertext","cipher","iv","counter","Counter","aesCtr","ModeOfOperation","ctr","decrypt","_getAccount","computedMAC","slice","substring","toLowerCase","Error","privateKey","throwError","errors","UNSUPPORTED_OPERATION","operation","mnemonicKey","address","check","account","mnemonicCiphertext","mnemonicIv","mnemonicCounter","mnemonicAesCtr","path","locale","entropy","node","fromMnemonic","derivePath","error","code","INVALID_ARGUMENT","argument","pbkdf2Sync","passwordBytes","salt","count","dkLen","prfFunc","Promise","resolve","_computeKdfKey","password","pbkdf2Func","scryptFunc","progressCallback","kdf","name","throwArgumentError","N","parseInt","r","p","prf","decryptSync","json","JSON","parse","syncScrypt","encrypt","options","e","reject","srcMnemonic","client","length","uuidRandom","uuid","then","derivedKey","macPrefix","mac","id","Crypto","cipherparams","kdfparams","n","dklen","now","Date","timestamp","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","gethFilename","stringify"],"sources":["C:\\Users\\kiril\\Desktop\\newenvai\\client\\node_modules\\@ethersproject\\json-wallets\\src.ts\\keystore.ts"],"sourcesContent":["\"use strict\";\n\nimport aes from \"aes-js\";\nimport scrypt from \"scrypt-js\";\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, Bytes, BytesLike, concat, hexlify } from \"@ethersproject/bytes\";\nimport { defaultPath, entropyToMnemonic, HDNode, Mnemonic, mnemonicToEntropy } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { Description } from \"@ethersproject/properties\";\nimport { computeAddress } from \"@ethersproject/transactions\";\n\nimport { getPassword, looseArrayify, searchPath, uuidV4, zpad } from \"./utils\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Exported Types\n\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\n    return (value != null && value.mnemonic && value.mnemonic.phrase);\n}\n\nexport interface _KeystoreAccount {\n    address: string;\n    privateKey: string;\n    mnemonic?: Mnemonic;\n\n    _isKeystoreAccount: boolean;\n}\n\nexport class KeystoreAccount extends Description<_KeystoreAccount> implements ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n    readonly mnemonic?: Mnemonic;\n\n    readonly _isKeystoreAccount: boolean;\n\n    isKeystoreAccount(value: any): value is KeystoreAccount {\n        return !!(value && value._isKeystoreAccount);\n    }\n}\n\nexport type ProgressCallback = (percent: number) => void;\n\nexport type EncryptOptions = {\n   iv?: BytesLike;\n   entropy?: BytesLike;\n   client?: string;\n   salt?: BytesLike;\n   uuid?: string;\n   scrypt?: {\n       N?: number;\n       r?: number;\n       p?: number;\n   }\n}\n\nfunction _decrypt(data: any, key: Uint8Array, ciphertext: Uint8Array): Uint8Array {\n    const cipher = searchPath(data, \"crypto/cipher\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"))\n        const counter = new aes.Counter(iv);\n\n        const aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n\n        return arrayify(aesCtr.decrypt(ciphertext));\n    }\n\n    return null;\n}\n\nfunction _getAccount(data: any, key: Uint8Array): KeystoreAccount {\n    const ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\n\n    const computedMAC = hexlify(keccak256(concat([ key.slice(16, 32), ciphertext ]))).substring(2);\n    if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\n        throw new Error(\"invalid password\");\n    }\n\n    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n\n    if (!privateKey) {\n        logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"decrypt\"\n        });\n    }\n\n    const mnemonicKey = key.slice(32, 64);\n\n    const address = computeAddress(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (check.substring(0, 2) !== \"0x\") { check = \"0x\" + check; }\n\n        if (getAddress(check) !== address) {\n            throw new Error(\"address mismatch\");\n        }\n    }\n\n    const account: _KeystoreAccount = {\n        _isKeystoreAccount: true,\n        address: address,\n        privateKey: hexlify(privateKey)\n    };\n\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\n        const mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n        const mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\n\n        const mnemonicCounter = new aes.Counter(mnemonicIv);\n        const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n\n        const path = searchPath(data, \"x-ethers/path\") || defaultPath;\n        const locale = searchPath(data, \"x-ethers/locale\") || \"en\";\n\n        const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n\n        try {\n            const mnemonic = entropyToMnemonic(entropy, locale);\n            const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n\n            account.mnemonic = node.mnemonic;\n\n        } catch (error) {\n            // If we don't have the locale wordlist installed to\n            // read this mnemonic, just bail and don't set the\n            // mnemonic\n            if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n                throw error;\n            }\n        }\n    }\n\n    return new KeystoreAccount(account);\n}\n\ntype ScryptFunc<T> = (pw: Uint8Array, salt: Uint8Array, n: number, r: number, p: number, dkLen: number, callback?: ProgressCallback) => T;\ntype Pbkdf2Func<T> = (pw: Uint8Array, salt: Uint8Array, c: number, dkLen: number, prfFunc: string) => T;\n\nfunction pbkdf2Sync(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Uint8Array {\n    return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction pbkdf2(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Promise<Uint8Array> {\n    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction _computeKdfKey<T>(data: any, password: Bytes | string, pbkdf2Func: Pbkdf2Func<T>, scryptFunc: ScryptFunc<T>, progressCallback?: ProgressCallback): T {\n    const passwordBytes = getPassword(password);\n\n    const kdf = searchPath(data, \"crypto/kdf\");\n\n    if (kdf && typeof(kdf) === \"string\") {\n        const throwError = function(name: string, value: any): never {\n            return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n        }\n\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n            const N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\n            const r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\n            const p = parseInt(searchPath(data, \"crypto/kdfparams/p\"));\n\n            // Check for all required parameters\n            if (!N || !r || !p) { throwError(\"kdf\", kdf); }\n\n            // Make sure N is a power of 2\n            if ((N & (N - 1)) !== 0) { throwError(\"N\", N); }\n\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) { throwError(\"dklen\", dkLen); }\n\n            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n\n        } else if (kdf.toLowerCase() === \"pbkdf2\") {\n\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n\n            let prfFunc: string = null;\n            const prf = searchPath(data, \"crypto/kdfparams/prf\");\n            if (prf === \"hmac-sha256\") {\n                prfFunc = \"sha256\";\n            } else if (prf === \"hmac-sha512\") {\n                prfFunc = \"sha512\";\n            } else {\n                throwError(\"prf\", prf);\n            }\n\n            const count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\n\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) { throwError(\"dklen\", dkLen); }\n\n            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n        }\n    }\n\n    return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n}\n\n\nexport function decryptSync(json: string, password: Bytes | string): KeystoreAccount {\n    const data = JSON.parse(json);\n\n    const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\n    return _getAccount(data, key);\n}\n\nexport async function decrypt(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<KeystoreAccount> {\n    const data = JSON.parse(json);\n\n    const key = await _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\n    return _getAccount(data, key);\n}\n\n\nexport function encrypt(account: ExternallyOwnedAccount, password: Bytes | string, options?: EncryptOptions, progressCallback?: ProgressCallback): Promise<string> {\n\n    try {\n        // Check the address matches the private key\n        if (getAddress(account.address) !== computeAddress(account.privateKey)) {\n            throw new Error(\"address/privateKey mismatch\");\n        }\n\n        // Check the mnemonic (if any) matches the private key\n        if (hasMnemonic(account)) {\n            const mnemonic = account.mnemonic;\n            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\n\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n        }\n\n    } catch (e) {\n        return Promise.reject(e);\n    }\n\n    // The options are optional, so adjust the call as needed\n    if (typeof(options) === \"function\" && !progressCallback) {\n        progressCallback = options;\n        options = {};\n    }\n    if (!options) { options = {}; }\n\n    const privateKey: Uint8Array = arrayify(account.privateKey);\n    const passwordBytes = getPassword(password);\n\n    let entropy: Uint8Array = null\n    let path: string = null;\n    let locale: string = null;\n    if (hasMnemonic(account)) {\n        const srcMnemonic = account.mnemonic;\n        entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n        path = srcMnemonic.path || defaultPath;\n        locale = srcMnemonic.locale || \"en\";\n    }\n\n    let client = options.client;\n    if (!client) { client = \"ethers.js\"; }\n\n    // Check/generate the salt\n    let salt: Uint8Array = null;\n    if (options.salt) {\n        salt = arrayify(options.salt);\n    } else {\n        salt = randomBytes(32);;\n    }\n\n    // Override initialization vector\n    let iv: Uint8Array = null;\n    if (options.iv) {\n        iv = arrayify(options.iv);\n        if (iv.length !== 16) { throw new Error(\"invalid iv\"); }\n    } else {\n       iv = randomBytes(16);\n    }\n\n    // Override the uuid\n    let uuidRandom: Uint8Array = null;\n    if (options.uuid) {\n        uuidRandom = arrayify(options.uuid);\n        if (uuidRandom.length !== 16) { throw new Error(\"invalid uuid\"); }\n    } else {\n        uuidRandom = randomBytes(16);\n    }\n\n    // Override the scrypt password-based key derivation function parameters\n    let N = (1 << 17), r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) { N = options.scrypt.N; }\n        if (options.scrypt.r) { r = options.scrypt.r; }\n        if (options.scrypt.p) { p = options.scrypt.p; }\n    }\n\n    // We take 64 bytes:\n    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {\n        key = arrayify(key);\n\n        // This will be used to encrypt the wallet (as per Web3 secret storage)\n        const derivedKey = key.slice(0, 16);\n        const macPrefix = key.slice(16, 32);\n\n        // This will be used to encrypt the mnemonic phrase (if any)\n        const mnemonicKey = key.slice(32, 64);\n\n        // Encrypt the private key\n        const counter = new aes.Counter(iv);\n        const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n        const ciphertext = arrayify(aesCtr.encrypt(privateKey));\n\n        // Compute the message authentication code, used to check the password\n        const mac = keccak256(concat([macPrefix, ciphertext]))\n\n        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n        const data: { [key: string]: any } = {\n            address: account.address.substring(2).toLowerCase(),\n            id: uuidV4(uuidRandom),\n            version: 3,\n            Crypto: {\n                cipher: \"aes-128-ctr\",\n                cipherparams: {\n                    iv: hexlify(iv).substring(2),\n                },\n                ciphertext: hexlify(ciphertext).substring(2),\n                kdf: \"scrypt\",\n                kdfparams: {\n                    salt: hexlify(salt).substring(2),\n                    n: N,\n                    dklen: 32,\n                    p: p,\n                    r: r\n                },\n                mac: mac.substring(2)\n            }\n        };\n\n        // If we have a mnemonic, encrypt it into the JSON wallet\n        if (entropy) {\n            const mnemonicIv = randomBytes(16);\n            const mnemonicCounter = new aes.Counter(mnemonicIv);\n            const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n            const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\n            const now = new Date();\n            const timestamp = (now.getUTCFullYear() + \"-\" +\n                               zpad(now.getUTCMonth() + 1, 2) + \"-\" +\n                               zpad(now.getUTCDate(), 2) + \"T\" +\n                               zpad(now.getUTCHours(), 2) + \"-\" +\n                               zpad(now.getUTCMinutes(), 2) + \"-\" +\n                               zpad(now.getUTCSeconds(), 2) + \".0Z\"\n                              );\n            data[\"x-ethers\"] = {\n                client: client,\n                gethFilename: (\"UTC--\" + timestamp + \"--\" + data.address),\n                mnemonicCounter: hexlify(mnemonicIv).substring(2),\n                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n                path: path,\n                locale: locale,\n                version: \"0.1\"\n            };\n        }\n\n        return JSON.stringify(data);\n    });\n}\n"]},"metadata":{},"sourceType":"module"}